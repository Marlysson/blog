<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Daily Development - Marlysson Silva</title><link href="https://marlysson.github.io/" rel="alternate"></link><link href="https://marlysson.github.io/feeds/marlysson-silva.atom.xml" rel="self"></link><id>https://marlysson.github.io/</id><updated>2017-02-12T05:00:00-03:00</updated><entry><title>Princípios de boas práticas em Orientação a Objetos</title><link href="https://marlysson.github.io/principios-solid-a-teoria.html" rel="alternate"></link><published>2017-02-12T05:00:00-03:00</published><updated>2017-02-12T05:00:00-03:00</updated><author><name>Marlysson Silva</name></author><id>tag:marlysson.github.io,2017-02-12:/principios-solid-a-teoria.html</id><summary type="html">&lt;p&gt;No desenvolvimento de software, nós desenvolvedores sempre presamos por construir sistema que sejam o mais fiel possível ao pedido do cliente ( por mais que haja mudanças no decorrer do tempo ) , mas além de tudo presamos por outros fatores que acontecem no decorrer ou após o desenvolvimento.&lt;/p&gt;</summary><content type="html">&lt;p&gt;No desenvolvimento de software, nós desenvolvedores sempre presamos por construir sistema que sejam o mais fiel possível ao pedido do cliente ( por mais que haja mudanças no decorrer do tempo ) , mas além de tudo presamos por outros fatores que acontecem no decorrer ou após o desenvolvimento.&lt;/p&gt;
&lt;h4&gt;Mudanças&lt;/h4&gt;
&lt;p&gt;Talvez seja um dos principais motivos para focarmos em um bom desenvolvimento de softwares: poder adaptar à mudanças que possam ocorrer nas regras de negócios ( o que é totalmente plausível ) . Um dos princípios SOLID fala justamente nesse fator, poder construir um software que quando for solicitado alguma mudança não seja alterado o código existente, seja adicionado algo novo para poder suprir essa mudança que ocorreu.&lt;/p&gt;
&lt;h4&gt;Entrada de um novo desenvolvedor&lt;/h4&gt;
&lt;p&gt;Em toda a equipe de desenvolvedores com certeza poderá haver a chegada de um novo integrante , e tem vez que um software mal escrito pode causar até uma demora na adaptação desse novo integrante na equipe, visto que não entenderá muito bem o que determinada classe faz no sistema como um todo ou até ficar um mal entendido na função dela e continuar o desenvolvimento com algum tipo de erro.&lt;/p&gt;
&lt;h4&gt;Manutenção&lt;/h4&gt;
&lt;p&gt;A maioria dos softwares precisam em algum momento de sua existência de uma manutenção , seja para consertar algum bug que apareceu ou pra ajustar algo que não se adaptou bem na sua instalação no local onde ficaria instalado, e os SOLID facilitariam isso pois o sistema estaria estruturado de uma maneira que seria mais fácil ( ou menos dolorido ) encontrar o bug que deu origem à manutenção do software , pois de certa forma o próprio software “falaria” qual o tipo de erro que ocorreu , e não uma forma genérica; por exemplo , uma exception levantada do tipo &lt;code&gt;RuntimeException&lt;/code&gt; pois assim não diria muita coisa sobre o erro, para facilitar teria várias mensagens customizadas de exceções que podem ter ocorrido durante o erro ( mensagens de regras de negócio ) e assim ir direto ao tipo do erro e poder solucioná-lo.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Observação:&lt;/strong&gt; Sobre existir manutenção em softwares: Por que após mais de 40 anos de experiência em desenvolvimento de software e milhares de livros feitos na área de Engenharia de Software sobre formas de conduzir desenvolvimentos de softwares corretos, ainda existe softwares com falhas nos negócios e que precisam de manutenção? Teoricamente não era pra haver mais softwares com manutenção devido ao tempo de “prática” na área..&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bom , passado a parte do que um bom código escrito usando os SOLID resolveria, vamos falar dos “bad smell” (Mau cheiro) , termo cunhado por &lt;strong&gt;Robert C. Martin - Uncle Bob&lt;/strong&gt;, para falar de uma forma humorada dos “cheiros“ que um código mal escrito “exala” .&lt;/p&gt;
&lt;h2&gt;Exemplos de Bad Smell&lt;/h2&gt;
&lt;h4&gt;Rigidez&lt;/h4&gt;
&lt;p&gt;Esse mau cheiro diz respeito ao quanto o software é difícil crescer ou mudar , quando ele é muito amarrado a implementações de outras partes do software , ou seja , possui um alto acoplamento com outras classes, em que se mudar algo em algumas das suas dependências haverá algum efeito colateral na classe que a usa. Exemplos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Efeitos colaterais internos ao mudar implementação das suas dependências.&lt;/li&gt;
&lt;li&gt;Uso exagerado de herança, onde mudando na classe mãe, mudará necessariamente nas suas filhas, causando uma cascata de alterações involuntárias.&lt;/li&gt;
&lt;li&gt;Pensar : “É muito mais difícil do que eu pensava” kkk . Faz parte.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Viscosidade&lt;/h4&gt;
&lt;p&gt;Diz respeito à facilidade que é fazer primeiramente o que é errado do que o certo em desenvolvimento de software, quando você tem uma funcionalidade pra implementar pensa primeiro em resolver o determinado problema do que abstraí-lo e pensar mais abstratamente podendo prever futuros problemas que podem acontecer, e pensando em abstrações você pode até tornar seu software adaptável à mudanças que venham a ocorrer, claro , não exagerar em abstrações, pois pode ser que haja por exemplo uma abstração e somente uma classe use ela.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nesse tópico entra a parte dos testes, que é uma das maiores resistências dos desenvolvedores, fazendo os testes do software , &lt;em&gt;TDD&lt;/em&gt; , você modela como seu software funcionará e ainda estará testando diversos cenários onde seu software atuará, facilitando assim refatorações futuras, pois estará apoiado nos testes quando mudar determinada implementação, não tendo toda hora que testar input após input do seu sistema, o que geralmente torna o teste manual do sistema custoso.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Repetição Desnecessária&lt;/h4&gt;
&lt;p&gt;Nesse mau cheiro há o clássico copy-paste ( copiar - colar ) , quando ocorre o uso de muito ctrl+c + ctrl+v , copia a funcionalidade de um método e cola em outro porque tem um função parecida, ou se não houver um código bem encapsulado poderá ter um implementação solta no código e uma vez ou outra ter que usar em outro local, e como não está encapsulado ocorrer o mau cheiro da rigidez, não podendo reutilizar o método ( funcionalidade ) em outro local, e assim, causando repetições desnecessárias, exemplos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uso de ctrl+f ( procurar ) para encontrar os diversos lugares em que existe determinada implementação quando for mudá-la.&lt;/li&gt;
&lt;li&gt;Uso de ctrl+c + ctrl+v em vários lugares.&lt;/li&gt;
&lt;li&gt;Uso exagerado de perguntas à objetos de qual tipo ou sobre determinada informação em que se está interessado , por exemplo : perguntar a função de determinado objeto funcionário para aplicar determinado desconto no seu salário, o que poderia ser resolvido com polimorfismo.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Objetos devem falar o que querem fazer e não perguntar aos outros se eles estão aptos a resolver seus problemas. &lt;strong&gt;Objects should tell , don't ask&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Copiar / Colar em editores de textos é aceitável, mas em desenvolvimento de software pode ser catastrófico.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Complexidade Desnecessária&lt;/h4&gt;
&lt;p&gt;Esse mau cheiro é característico da “melhora antecipada” , pois o desenvolvedor começa já aplicando diversas implementações no código para poder ter um melhor aproveitamento de performance no código , o mais clássico que vejo é: “Um for de determinado jeito é mais rápido?”, ele começa antecipar ocasiões futuras que podem nunca ocorrer, como suportar milhões de usuários no sistema dele, no caso de desempenho, tem também a parte de criar abstrações desnecessárias, já começa a aplicar padrões de projeto nas primeiras linhas do código , sendo que eles servem para fazer refatorações em códigos já bem estruturados , com Padrões de Projeto no início causa uma complexidade antecipada que pode custar um design bem feito do software. Exemplos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Usando operadores ternários com 3 ou 4 verificações, por exemplo, PHP;&lt;/li&gt;
&lt;li&gt;Usando funções &lt;code&gt;lambda&lt;/code&gt; com vários argumentos e ainda adiciona uns map’s , filter’s .. tudo inline ainda por cima, por exemplo , Python;&lt;/li&gt;
&lt;li&gt;Operadores bitwise com vários shifts e usando números mágicos para essas manipulações pra lá e pra cá, depois a pessoa nem lembra pra que servia o número.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Uma dica:&lt;/strong&gt; quando ver um &lt;strong&gt;mau cheiro forte&lt;/strong&gt; espere um tempo até consertá-lo, por exemplo nas abstrações, espere aparecer um caso em que precise para poder criá-las. Pois pode ficar um outro mau cheiro : complexidade desnecessária.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“Permita-se levar o primeiro tipo“&lt;/strong&gt; , após ele analise o problema e proponha uma solução.&lt;/p&gt;
&lt;p&gt;No caso dos exemplos citado, prova que não é a ferramenta que influencia o programador a fazer a coisa errada, e sim o uso exagerado e exacerbado de determinadas funções da linguagem , e até o seu desconhecimento de parte das funcionalidades da linguagem, fazendo o programador não utilizar as melhores práticas e o que é recomendado .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Opacidade&lt;/h4&gt;
&lt;p&gt;Esse mau cheiro é clássico de código mau escrito, porque fala a respeito do quanto o próprio desenvolvedor não consegue mais ler seu próprio código , e assim se nem ele sabe explicar fica difícil .. :D . Esse mau cheiro se relaciona com o da viscosidade, pois quando mais fácil o desenvolvedor se inclinar em fazer a implementação imediatista que nem sempre é a melhor e mais completa , fica mais fácil ele fazer uma solução que fique um tanto implícita, que fique difícil de entender, por exemplo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nomear variáveis que não representam muito o seu significado , por exemplo: a, pg, num… e por ai vai.&lt;/li&gt;
&lt;li&gt;Uso de magic strings para fazer representações de elementos no código , por exemplo: PG , NPG , AGNDD , para representar os status de uma compra ( PAGO , NÃO-PAGO , AGENDADO ) , além de magic numbers para o mesmo propósito: 0, 1, 2, 3 …&lt;/li&gt;
&lt;li&gt;Uso exagerado de comentários, onde o próprio código já teria que ser explicativo o bastante para dizer o que ele está fazendo. Existência de muitos comentários pode ser um mau indício.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Fragilidade&lt;/h4&gt;
&lt;p&gt;A fragilidade diz respeito à fraqueza do design do software , em que uma pequena mudança em uma determinada parte do código causa diversas mudanças em outras partes , o pior , partes que não estão nem relacionadas, os desenvolvedores podem nem saber as conexões que existem ao longo das classes. Exemplos :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dizem : “Nem cheguem perto ou mexam nessa classe”, tipo uma classe “god” que faz várias coisas , tipo amarra o sistema pra não cair.&lt;/li&gt;
&lt;li&gt;Manda o estagiário revisar determinada parte do código , fazer uma refatoração, pois dará muitos problemas, deixar ele um pouco lá resolvendo :D .&lt;/li&gt;
&lt;li&gt;Desenvolvedores tem medo de mexer em determinada parte do código por receio de causar vários problemas em cascata no resto do sistema.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A diferença com a rigidez é que aqui, por mais pequena que seja a mudança causa vários efeitos colaterais, já na rigidez, o desenvolvedor não pode mudar nada pois está tudo muito acoplado.&lt;/p&gt;
&lt;h4&gt;Imobilidade&lt;/h4&gt;
&lt;p&gt;Diz respeito ao alto acoplamento dos diversos componentes do sistema, com esse mau cheiro fica muito difícil decompor o sistema em módulos reutilizáveis , uma determinada função em uma classe poderia ser decomposta em uma classe e ser reutilizável no sistema como um todo, mas essa determinada função está intimamente ligada à implementação de uma parte do sistema, ficando impedido de retirá-la de lá e poder desacoplá-la e abstrair. Veja que relaciona com outros bad smells , por exemplo , a rigidez , onde o design do software está muito amarrado à implementações. Quando mais bad smells tiver, mais “estragado” estará o seu sistema :D . Exemplos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implementações intimamente ligadas a componentes, dificultando o desacoplamento, abstração.&lt;/li&gt;
&lt;/ul&gt;</content><category term="Orientação a Objetos"></category><category term="Boas Práticas"></category></entry></feed>